# 法律咨询助手系统开发文档

## 1. 项目结构

### 1.1 Maven项目结构

```
legal-assistant/
├── src/main/java/com/legal/assistant/
│   ├── LegalAssistantApplication.java
│   ├── config/                      # 配置类
│   │   ├── RedisConfig.java
│   │   ├── MinioConfig.java
│   │   ├── MilvusConfig.java
│   │   ├── AgentConfig.java
│   │   ├── WebMvcConfig.java
│   │   ├── JwtConfig.java           # JWT配置
│   │   └── SecurityConfig.java      # 安全配置
│   ├── controller/                  # 控制器
│   │   ├── AuthController.java      # 认证控制器
│   │   ├── UserController.java      # 用户控制器
│   │   ├── ChatController.java
│   │   ├── FileController.java
│   │   ├── ConversationController.java
│   │   ├── ShareController.java
│   │   └── KnowledgeBaseController.java
│   ├── service/                     # 服务层
│   │   ├── AuthService.java          # 认证服务
│   │   ├── UserService.java         # 用户服务
│   │   ├── SmsService.java          # 短信服务
│   │   ├── ChatService.java
│   │   ├── FileService.java
│   │   ├── ConversationService.java
│   │   ├── ShareService.java
│   │   ├── VectorService.java
│   │   └── agent/                   # Agent服务
│   │       ├── AgentService.java
│   │       ├── LegalConsultationAgent.java
│   │       ├── RiskAssessmentAgent.java
│   │       ├── DisputeFocusAgent.java
│   │       └── CaseAnalysisAgent.java
│   ├── service/impl/                # 服务实现
│   ├── mapper/                      # MyBatis映射器
│   │   ├── UserMapper.java
│   │   ├── ConversationMapper.java
│   │   ├── MessageMapper.java
│   │   ├── FileMapper.java
│   │   ├── ShareMapper.java
│   │   └── KnowledgeBaseMapper.java
│   ├── entity/                      # 实体类
│   │   ├── User.java
│   │   ├── Conversation.java
│   │   ├── Message.java
│   │   ├── File.java
│   │   ├── Share.java
│   │   └── KnowledgeBase.java
│   ├── dto/                         # 数据传输对象
│   │   ├── request/
│   │   │   ├── LoginRequest.java
│   │   │   ├── SendCodeRequest.java
│   │   │   ├── UpdateUserRequest.java
│   │   │   ├── ChatRequest.java
│   │   │   ├── FileUploadRequest.java
│   │   │   └── ConversationRequest.java
│   │   └── response/
│   │       ├── LoginResponse.java
│   │       ├── UserInfoResponse.java
│   │       ├── ChatResponse.java
│   │       ├── FileResponse.java
│   │       └── ConversationResponse.java
│   ├── enums/                       # 枚举类
│   │   ├── ModelType.java
│   │   ├── AgentType.java
│   │   ├── FileType.java
│   │   └── MessageRole.java
│   ├── exception/                   # 异常处理
│   │   ├── GlobalExceptionHandler.java
│   │   ├── BusinessException.java
│   │   └── ErrorCode.java
│   ├── interceptor/                 # 拦截器
│   │   └── AuthInterceptor.java     # Token认证拦截器
│   ├── annotation/                  # 注解
│   │   └── NoAuth.java              # 无需认证注解
│   └── utils/                       # 工具类
│       ├── JwtUtils.java            # JWT工具类
│       ├── FileUtils.java
│       ├── MarkdownConverter.java
│       ├── OcrUtils.java
│       └── VectorUtils.java
├── src/main/resources/
│   ├── application.yml
│   ├── application-dev.yml
│   ├── application-prod.yml
│   └── mapper/                      # MyBatis XML映射文件
└── pom.xml
```

### 1.2 核心依赖

xml

```xml
<!-- pom.xml -->
<dependencies>
    <!-- Spring Boot 3 -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    
    <!-- MyBatis Plus -->
    <dependency>
        <groupId>com.baomidou</groupId>
        <artifactId>mybatis-plus-boot-starter</artifactId>
        <version>3.5.5</version>
    </dependency>
    
    <!-- MySQL -->
    <dependency>
        <groupId>com.mysql</groupId>
        <artifactId>mysql-connector-j</artifactId>
    </dependency>
    
    <!-- Redis -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-redis</artifactId>
    </dependency>
    
    <!-- MinIO -->
    <dependency>
        <groupId>io.minio</groupId>
        <artifactId>minio</artifactId>
        <version>8.5.7</version>
    </dependency>
    
    <!-- Milvus -->
    <dependency>
        <groupId>io.milvus</groupId>
        <artifactId>milvus-sdk-java</artifactId>
        <version>2.3.4</version>
    </dependency>
    
    <!-- 文档处理 -->
    <dependency>
        <groupId>org.apache.pdfbox</groupId>
        <artifactId>pdfbox</artifactId>
        <version>3.0.1</version>
    </dependency>
    
    <dependency>
        <groupId>org.apache.poi</groupId>
        <artifactId>poi-ooxml</artifactId>
        <version>5.2.5</version>
    </dependency>
    
    <!-- Markdown处理 -->
    <dependency>
        <groupId>com.vladsch.flexmark</groupId>
        <artifactId>flexmark-all</artifactId>
        <version>0.64.8</version>
    </dependency>
    
    <!-- OCR -->
    <dependency>
        <groupId>net.sourceforge.tess4j</groupId>
        <artifactId>tess4j</artifactId>
        <version>5.9.0</version>
    </dependency>
    
    <!-- Lombok -->
    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
    </dependency>
    
    <!-- Validation -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-validation</artifactId>
    </dependency>
    
    <!-- JWT -->
    <dependency>
        <groupId>io.jsonwebtoken</groupId>
        <artifactId>jjwt-api</artifactId>
        <version>0.12.3</version>
    </dependency>
    <dependency>
        <groupId>io.jsonwebtoken</groupId>
        <artifactId>jjwt-impl</artifactId>
        <version>0.12.3</version>
        <scope>runtime</scope>
    </dependency>
    <dependency>
        <groupId>io.jsonwebtoken</groupId>
        <artifactId>jjwt-jackson</artifactId>
        <version>0.12.3</version>
        <scope>runtime</scope>
    </dependency>
    
    <!-- 短信服务(可选,根据实际使用的短信服务商选择) -->
    <!-- 示例: 阿里云短信服务 -->
    <dependency>
        <groupId>com.aliyun</groupId>
        <artifactId>dysmsapi20170525</artifactId>
        <version>2.0.24</version>
    </dependency>
</dependencies>
```

## 2. 配置文件

### 2.1 application.yml

yaml

```yaml
spring:
  application:
    name: legal-assistant
  
  # 数据源配置
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://localhost:3306/legal_assistant?useUnicode=true&characterEncoding=utf8&serverTimezone=Asia/Shanghai
    username: root
    password: your_password
    hikari:
      maximum-pool-size: 20
      minimum-idle: 5
      connection-timeout: 30000
  
  # Redis配置
  data:
    redis:
      host: localhost
      port: 6379
      password: 
      database: 0
      lettuce:
        pool:
          max-active: 8
          max-idle: 8
          min-idle: 0
  
  # 文件上传配置
  servlet:
    multipart:
      max-file-size: 100MB
      max-request-size: 100MB

# MyBatis Plus配置
mybatis-plus:
  mapper-locations: classpath*:mapper/**/*.xml
  type-aliases-package: com.legal.assistant.entity
  configuration:
    map-underscore-to-camel-case: true
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl
  global-config:
    db-config:
      logic-delete-field: isDeleted
      logic-delete-value: 1
      logic-not-delete-value: 0

# MinIO配置
minio:
  endpoint: http://localhost:9000
  access-key: minioadmin
  secret-key: minioadmin
  bucket-name: legal-assistant
  
# Milvus配置
milvus:
  host: localhost
  port: 19530
  collection-name: legal_documents
  dimension: 1536

# AgentScope配置
agentscope:
  api-key: your_deepseek_api_key
  base-url: https://api.deepseek.com
  timeout: 60000

# JWT配置
jwt:
  secret: your_jwt_secret_key_should_be_long_and_random
  expiration: 604800000  # 7天,单位:毫秒
  refresh-expiration: 2592000000  # 30天,单位:毫秒

# 短信服务配置(示例:阿里云)
sms:
  access-key-id: your_access_key_id
  access-key-secret: your_access_key_secret
  sign-name: 法律咨询助手
  template-code: SMS_123456789
  code-expiration: 300  # 验证码有效期5分钟,单位:秒
  send-limit-per-minute: 1  # 每分钟发送限制
  send-limit-per-day: 10  # 每天发送限制

# 业务配置
business:
  share:
    default-expiration-days: 7
    max-expiration-days: 30
  conversation:
    soft-delete-days: 30
  ocr:
    language: chi_sim+eng
  user:
    default-nickname-prefix: 用户
    avatar-max-size: 5242880  # 5MB,单位:字节
    bio-max-length: 500
    nickname-min-length: 2
    nickname-max-length: 20
    deactivate-retention-days: 30  # 注销后保留天数
```

## 3. 数据库表结构

### 3.1 用户表(user)

```sql
CREATE TABLE `user` (
  `id` BIGINT NOT NULL AUTO_INCREMENT COMMENT '主键ID',
  `nickname` VARCHAR(20) NOT NULL DEFAULT '' COMMENT '昵称',
  `phone` VARCHAR(11) NOT NULL COMMENT '手机号',
  `avatar` VARCHAR(255) DEFAULT NULL COMMENT '头像URL',
  `bio` VARCHAR(500) DEFAULT NULL COMMENT '个人简介',
  `is_enabled` TINYINT(1) NOT NULL DEFAULT 1 COMMENT '是否可用(0:禁用,1:启用)',
  `is_deleted` TINYINT(1) NOT NULL DEFAULT 0 COMMENT '是否删除(0:未删除,1:已删除)',
  `created_at` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `updated_at` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
  `last_login_at` DATETIME DEFAULT NULL COMMENT '最后登录时间',
  `last_login_ip` VARCHAR(50) DEFAULT NULL COMMENT '最后登录IP',
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_phone` (`phone`),
  KEY `idx_is_deleted` (`is_deleted`),
  KEY `idx_created_at` (`created_at`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='用户表';
```

## 4. 核心代码实现

### 4.1 用户实体类

```java
// User.java
package com.legal.assistant.entity;

import com.baomidou.mybatisplus.annotation.*;
import lombok.Data;
import java.time.LocalDateTime;

@Data
@TableName("user")
public class User {
    @TableId(type = IdType.AUTO)
    private Long id;
    
    private String nickname;
    
    @TableField("phone")
    private String phone;
    
    private String avatar;
    
    private String bio;
    
    @TableField("is_enabled")
    private Boolean isEnabled;
    
    @TableLogic
    @TableField("is_deleted")
    private Boolean isDeleted;
    
    @TableField(value = "created_at", fill = FieldFill.INSERT)
    private LocalDateTime createdAt;
    
    @TableField(value = "updated_at", fill = FieldFill.INSERT_UPDATE)
    private LocalDateTime updatedAt;
    
    @TableField("last_login_at")
    private LocalDateTime lastLoginAt;
    
    @TableField("last_login_ip")
    private String lastLoginIp;
}
```

### 4.2 认证相关DTO

```java
// LoginRequest.java
package com.legal.assistant.dto.request;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Pattern;
import lombok.Data;

@Data
public class LoginRequest {
    @NotBlank(message = "手机号不能为空")
    @Pattern(regexp = "^1[3-9]\\d{9}$", message = "手机号格式不正确")
    private String phone;
    
    @NotBlank(message = "验证码不能为空")
    @Pattern(regexp = "^\\d{6}$", message = "验证码必须是6位数字")
    private String code;
}

// LoginResponse.java
package com.legal.assistant.dto.response;

import lombok.Data;

@Data
public class LoginResponse {
    private String token;
    private String refreshToken;
    private Long userId;
    private String nickname;
    private String avatar;
    private Long expiresIn;  // Token过期时间(秒)
}

// UpdateUserRequest.java
package com.legal.assistant.dto.request;

import jakarta.validation.constraints.Size;
import lombok.Data;

@Data
public class UpdateUserRequest {
    @Size(min = 2, max = 20, message = "昵称长度必须在2-20个字符之间")
    private String nickname;
    
    private String avatar;
    
    @Size(max = 500, message = "个人简介不能超过500个字符")
    private String bio;
}

// UserInfoResponse.java
package com.legal.assistant.dto.response;

import lombok.Data;
import java.time.LocalDateTime;

@Data
public class UserInfoResponse {
    private Long id;
    private String nickname;
    private String phone;  // 脱敏显示,如: 138****5678
    private String avatar;
    private String bio;
    private LocalDateTime createdAt;
    private LocalDateTime lastLoginAt;
}
```

### 4.3 JWT工具类

```java
// JwtUtils.java
package com.legal.assistant.utils;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.security.Keys;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import javax.crypto.SecretKey;
import java.nio.charset.StandardCharsets;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;

@Component
public class JwtUtils {
    
    @Value("${jwt.secret}")
    private String secret;
    
    @Value("${jwt.expiration}")
    private Long expiration;
    
    @Value("${jwt.refresh-expiration}")
    private Long refreshExpiration;
    
    private SecretKey getSigningKey() {
        return Keys.hmacShaKeyFor(secret.getBytes(StandardCharsets.UTF_8));
    }
    
    /**
     * 生成Token
     */
    public String generateToken(Long userId, String phone) {
        Map<String, Object> claims = new HashMap<>();
        claims.put("userId", userId);
        claims.put("phone", phone);
        return createToken(claims, expiration);
    }
    
    /**
     * 生成刷新Token
     */
    public String generateRefreshToken(Long userId, String phone) {
        Map<String, Object> claims = new HashMap<>();
        claims.put("userId", userId);
        claims.put("phone", phone);
        claims.put("type", "refresh");
        return createToken(claims, refreshExpiration);
    }
    
    private String createToken(Map<String, Object> claims, Long expiration) {
        Date now = new Date();
        Date expiryDate = new Date(now.getTime() + expiration);
        
        return Jwts.builder()
                .claims(claims)
                .issuedAt(now)
                .expiration(expiryDate)
                .signWith(getSigningKey())
                .compact();
    }
    
    /**
     * 从Token中获取Claims
     */
    public Claims getClaimsFromToken(String token) {
        return Jwts.parser()
                .verifyWith(getSigningKey())
                .build()
                .parseSignedClaims(token)
                .getPayload();
    }
    
    /**
     * 从Token中获取用户ID
     */
    public Long getUserIdFromToken(String token) {
        Claims claims = getClaimsFromToken(token);
        return Long.valueOf(claims.get("userId").toString());
    }
    
    /**
     * 验证Token是否有效
     */
    public boolean validateToken(String token) {
        try {
            Claims claims = getClaimsFromToken(token);
            return !claims.getExpiration().before(new Date());
        } catch (Exception e) {
            return false;
        }
    }
}
```

### 4.4 认证拦截器

```java
// NoAuth.java
package com.legal.assistant.annotation;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
public @interface NoAuth {
    // 标记该接口无需Token认证
}

// AuthInterceptor.java
package com.legal.assistant.interceptor;

import com.legal.assistant.annotation.NoAuth;
import com.legal.assistant.utils.JwtUtils;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.stereotype.Component;
import org.springframework.web.method.HandlerMethod;
import org.springframework.web.servlet.HandlerInterceptor;

@Component
public class AuthInterceptor implements HandlerInterceptor {
    
    @Autowired
    private JwtUtils jwtUtils;
    
    @Autowired
    private RedisTemplate<String, String> redisTemplate;
    
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        // 如果不是方法处理器,直接放行
        if (!(handler instanceof HandlerMethod)) {
            return true;
        }
        
        HandlerMethod handlerMethod = (HandlerMethod) handler;
        
        // 检查是否有@NoAuth注解
        if (handlerMethod.hasMethodAnnotation(NoAuth.class) || 
            handlerMethod.getBeanType().isAnnotationPresent(NoAuth.class)) {
            return true;
        }
        
        // 获取Token
        String token = getTokenFromRequest(request);
        if (token == null || token.isEmpty()) {
            response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
            response.getWriter().write("{\"code\":401,\"message\":\"未提供Token\"}");
            return false;
        }
        
        // 验证Token
        if (!jwtUtils.validateToken(token)) {
            response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
            response.getWriter().write("{\"code\":401,\"message\":\"Token无效或已过期\"}");
            return false;
        }
        
        // 检查Token是否在黑名单中(如用户注销)
        if (redisTemplate.hasKey("token:blacklist:" + token)) {
            response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
            response.getWriter().write("{\"code\":401,\"message\":\"Token已失效\"}");
            return false;
        }
        
        // 将用户ID存储到request中,供后续使用
        Long userId = jwtUtils.getUserIdFromToken(token);
        request.setAttribute("userId", userId);
        
        return true;
    }
    
    private String getTokenFromRequest(HttpServletRequest request) {
        String bearerToken = request.getHeader("Authorization");
        if (bearerToken != null && bearerToken.startsWith("Bearer ")) {
            return bearerToken.substring(7);
        }
        return null;
    }
}
```

### 4.5 短信服务

```java
// SmsService.java
package com.legal.assistant.service;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

@Service
public class SmsService {
    
    @Value("${sms.access-key-id}")
    private String accessKeyId;
    
    @Value("${sms.access-key-secret}")
    private String accessKeySecret;
    
    @Value("${sms.sign-name}")
    private String signName;
    
    @Value("${sms.template-code}")
    private String templateCode;
    
    /**
     * 发送验证码短信
     * 注意: 这里只是示例,实际需要根据使用的短信服务商实现
     * 例如: 阿里云、腾讯云、云片等
     */
    public void sendCode(String phone, String code) {
        // TODO: 实现短信发送逻辑
        // 示例: 使用阿里云短信服务
        // 1. 构建短信内容
        // 2. 调用短信服务API
        // 3. 处理发送结果
        
        // 开发环境可以打印到日志,生产环境需要实际调用短信服务
        System.out.println("发送验证码到 " + phone + ": " + code);
    }
}
```

### 4.6 认证服务

```java
// AuthService.java
package com.legal.assistant.service;

import com.legal.assistant.dto.request.LoginRequest;
import com.legal.assistant.dto.response.LoginResponse;
import com.legal.assistant.entity.User;
import com.legal.assistant.exception.BusinessException;
import com.legal.assistant.mapper.UserMapper;
import com.legal.assistant.utils.JwtUtils;
import io.jsonwebtoken.Claims;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.concurrent.TimeUnit;

@Service
public class AuthService {
    
    @Autowired
    private UserMapper userMapper;
    
    @Autowired
    private SmsService smsService;
    
    @Autowired
    private JwtUtils jwtUtils;
    
    @Autowired
    private RedisTemplate<String, String> redisTemplate;
    
    /**
     * 发送验证码
     */
    public void sendCode(String phone) {
        // 检查发送频率限制
        String limitKey = "sms:limit:" + phone;
        String count = redisTemplate.opsForValue().get(limitKey);
        if (count != null && Integer.parseInt(count) >= 10) {
            throw new BusinessException("今日验证码发送次数已达上限");
        }
        
        // 生成6位验证码
        String code = String.format("%06d", (int)(Math.random() * 1000000));
        
        // 存储验证码到Redis,5分钟过期
        String codeKey = "sms:code:" + phone;
        redisTemplate.opsForValue().set(codeKey, code, 5, TimeUnit.MINUTES);
        
        // 更新发送次数
        redisTemplate.opsForValue().increment(limitKey);
        redisTemplate.expire(limitKey, 24, TimeUnit.HOURS);
        
        // 发送短信(实际项目中调用短信服务)
        smsService.sendCode(phone, code);
    }
    
    /**
     * 登录/注册
     */
    @Transactional
    public LoginResponse login(LoginRequest request, String clientIp) {
        // 验证验证码
        String codeKey = "sms:code:" + request.getPhone();
        String storedCode = redisTemplate.opsForValue().get(codeKey);
        if (storedCode == null || !storedCode.equals(request.getCode())) {
            throw new BusinessException("验证码错误或已过期");
        }
        
        // 验证成功后删除验证码
        redisTemplate.delete(codeKey);
        
        // 查找用户,如果不存在则创建
        User user = userMapper.selectByPhone(request.getPhone());
        boolean isNewUser = false;
        
        if (user == null) {
            // 自动注册
            user = new User();
            user.setPhone(request.getPhone());
            user.setNickname("用户" + request.getPhone().substring(7));  // 默认昵称
            user.setIsEnabled(true);
            user.setIsDeleted(false);
            user.setCreatedAt(LocalDateTime.now());
            user.setUpdatedAt(LocalDateTime.now());
            userMapper.insert(user);
            isNewUser = true;
        }
        
        // 更新登录信息
        user.setLastLoginAt(LocalDateTime.now());
        user.setLastLoginIp(clientIp);
        userMapper.updateById(user);
        
        // 生成Token
        String token = jwtUtils.generateToken(user.getId(), user.getPhone());
        String refreshToken = jwtUtils.generateRefreshToken(user.getId(), user.getPhone());
        
        // 构建响应
        LoginResponse response = new LoginResponse();
        response.setToken(token);
        response.setRefreshToken(refreshToken);
        response.setUserId(user.getId());
        response.setNickname(user.getNickname());
        response.setAvatar(user.getAvatar());
        response.setExpiresIn(604800L);  // 7天
        
        return response;
    }
    
    /**
     * 退出登录
     */
    public void logout(String token) {
        // 将Token加入黑名单
        Long userId = jwtUtils.getUserIdFromToken(token);
        redisTemplate.opsForValue().set("token:blacklist:" + token, "1", 7, TimeUnit.DAYS);
    }
    
    /**
     * 刷新Token
     */
    public LoginResponse refreshToken(String refreshToken) {
        if (!jwtUtils.validateToken(refreshToken)) {
            throw new BusinessException("刷新Token无效");
        }
        
        Claims claims = jwtUtils.getClaimsFromToken(refreshToken);
        if (!"refresh".equals(claims.get("type"))) {
            throw new BusinessException("Token类型错误");
        }
        
        Long userId = Long.valueOf(claims.get("userId").toString());
        String phone = claims.get("phone").toString();
        
        // 生成新的Token
        String newToken = jwtUtils.generateToken(userId, phone);
        String newRefreshToken = jwtUtils.generateRefreshToken(userId, phone);
        
        LoginResponse response = new LoginResponse();
        response.setToken(newToken);
        response.setRefreshToken(newRefreshToken);
        response.setUserId(userId);
        response.setExpiresIn(604800L);
        
        return response;
    }
}
```

### 4.7 用户服务

```java
// UserService.java
package com.legal.assistant.service;

import com.legal.assistant.dto.request.UpdateUserRequest;
import com.legal.assistant.dto.response.UserInfoResponse;
import com.legal.assistant.entity.User;
import com.legal.assistant.exception.BusinessException;
import com.legal.assistant.mapper.UserMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;

@Service
public class UserService {
    
    @Autowired
    private UserMapper userMapper;
    
    /**
     * 获取用户信息
     */
    public UserInfoResponse getUserInfo(Long userId) {
        User user = userMapper.selectById(userId);
        if (user == null || user.getIsDeleted()) {
            throw new BusinessException("用户不存在");
        }
        
        UserInfoResponse response = new UserInfoResponse();
        response.setId(user.getId());
        response.setNickname(user.getNickname());
        response.setPhone(maskPhone(user.getPhone()));  // 脱敏
        response.setAvatar(user.getAvatar());
        response.setBio(user.getBio());
        response.setCreatedAt(user.getCreatedAt());
        response.setLastLoginAt(user.getLastLoginAt());
        
        return response;
    }
    
    /**
     * 更新用户信息
     */
    @Transactional
    public void updateUserInfo(Long userId, UpdateUserRequest request) {
        User user = userMapper.selectById(userId);
        if (user == null || user.getIsDeleted()) {
            throw new BusinessException("用户不存在");
        }
        
        if (request.getNickname() != null) {
            user.setNickname(request.getNickname());
        }
        if (request.getAvatar() != null) {
            user.setAvatar(request.getAvatar());
        }
        if (request.getBio() != null) {
            user.setBio(request.getBio());
        }
        
        user.setUpdatedAt(LocalDateTime.now());
        userMapper.updateById(user);
    }
    
    /**
     * 注销账号
     */
    @Transactional
    public void deactivateAccount(Long userId, String code) {
        // 二次验证: 需要再次验证验证码
        User user = userMapper.selectById(userId);
        if (user == null || user.getIsDeleted()) {
            throw new BusinessException("用户不存在");
        }
        
        // 验证验证码(简化示例,实际需要调用SmsService验证)
        // ...
        
        // 软删除用户
        user.setIsDeleted(true);
        user.setUpdatedAt(LocalDateTime.now());
        userMapper.updateById(user);
        
        // 将用户的所有Token加入黑名单
        // (实际实现中需要维护用户Token列表)
    }
    
    /**
     * 手机号脱敏
     */
    private String maskPhone(String phone) {
        if (phone == null || phone.length() != 11) {
            return phone;
        }
        return phone.substring(0, 3) + "****" + phone.substring(7);
    }
}
```

### 4.8 Mapper接口

```java
// UserMapper.java
package com.legal.assistant.mapper;

import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import com.legal.assistant.entity.User;
import org.apache.ibatis.annotations.Mapper;
import org.apache.ibatis.annotations.Select;

@Mapper
public interface UserMapper extends BaseMapper<User> {
    
    /**
     * 根据手机号查询用户
     */
    @Select("SELECT * FROM user WHERE phone = #{phone} AND is_deleted = 0")
    User selectByPhone(String phone);
}
```

### 4.9 控制器实现

```java
// AuthController.java
package com.legal.assistant.controller;

import com.legal.assistant.annotation.NoAuth;
import com.legal.assistant.dto.request.LoginRequest;
import com.legal.assistant.dto.request.SendCodeRequest;
import com.legal.assistant.dto.response.LoginResponse;
import com.legal.assistant.service.AuthService;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.validation.Valid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/auth")
public class AuthController {
    
    @Autowired
    private AuthService authService;
    
    @NoAuth
    @PostMapping("/send-code")
    public void sendCode(@Valid @RequestBody SendCodeRequest request) {
        authService.sendCode(request.getPhone());
    }
    
    @NoAuth
    @PostMapping("/login")
    public LoginResponse login(@Valid @RequestBody LoginRequest request, HttpServletRequest httpRequest) {
        String clientIp = getClientIp(httpRequest);
        return authService.login(request, clientIp);
    }
    
    @PostMapping("/logout")
    public void logout(HttpServletRequest request) {
        String token = getTokenFromRequest(request);
        authService.logout(token);
    }
    
    @PostMapping("/refresh")
    public LoginResponse refreshToken(@RequestHeader("Authorization") String bearerToken) {
        String token = bearerToken.substring(7);
        return authService.refreshToken(token);
    }
    
    private String getClientIp(HttpServletRequest request) {
        String ip = request.getHeader("X-Forwarded-For");
        if (ip == null || ip.isEmpty() || "unknown".equalsIgnoreCase(ip)) {
            ip = request.getHeader("X-Real-IP");
        }
        if (ip == null || ip.isEmpty() || "unknown".equalsIgnoreCase(ip)) {
            ip = request.getRemoteAddr();
        }
        return ip;
    }
    
    private String getTokenFromRequest(HttpServletRequest request) {
        String bearerToken = request.getHeader("Authorization");
        if (bearerToken != null && bearerToken.startsWith("Bearer ")) {
            return bearerToken.substring(7);
        }
        return null;
    }
}

// UserController.java
package com.legal.assistant.controller;

import com.legal.assistant.dto.request.UpdateUserRequest;
import com.legal.assistant.dto.response.UserInfoResponse;
import com.legal.assistant.service.UserService;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.validation.Valid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/user")
public class UserController {
    
    @Autowired
    private UserService userService;
    
    @GetMapping("/info")
    public UserInfoResponse getUserInfo(HttpServletRequest request) {
        Long userId = (Long) request.getAttribute("userId");
        return userService.getUserInfo(userId);
    }
    
    @PutMapping("/info")
    public void updateUserInfo(@Valid @RequestBody UpdateUserRequest request, 
                               HttpServletRequest httpRequest) {
        Long userId = (Long) httpRequest.getAttribute("userId");
        userService.updateUserInfo(userId, request);
    }
    
    @PostMapping("/deactivate")
    public void deactivateAccount(@RequestParam String code, HttpServletRequest request) {
        Long userId = (Long) request.getAttribute("userId");
        userService.deactivateAccount(userId, code);
    }
}
```

### 4.10 Web配置

```java
// WebMvcConfig.java (补充拦截器配置)
package com.legal.assistant.config;

import com.legal.assistant.interceptor.AuthInterceptor;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class WebMvcConfig implements WebMvcConfigurer {
    
    @Autowired
    private AuthInterceptor authInterceptor;
    
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(authInterceptor)
                .addPathPatterns("/api/**")
                .excludePathPatterns(
                    "/api/auth/send-code",
                    "/api/auth/login",
                    "/api/share/**"  // 分享接口无需认证
                );
    }
}
```

### 4.11 接口认证说明

**需要Token认证的接口:**
- 所有 `/api/user/**` 接口
- 所有 `/api/chat/**` 接口
- 所有 `/api/file/**` 接口
- 所有 `/api/conversation/**` 接口(除分享相关)
- 所有 `/api/knowledge-base/**` 接口

**无需Token认证的接口:**
- `/api/auth/send-code` - 发送验证码
- `/api/auth/login` - 登录/注册
- `/api/share/{shareId}` - 访问分享链接(公开接口)
- `/api/share/{shareId}/verify` - 验证分享密码(公开接口)

**Token使用方式:**
- 请求头格式: `Authorization: Bearer {token}`
- Token有效期: 7天
- 刷新Token有效期: 30天

### 4.12 枚举定义

java

```java
// ModelType.java
package com.legal.assistant.enums;

import lombok.Getter;

@Getter
public enum ModelType {
    DEEPSEEK_CHAT("deepseek-chat", "DeepSeek对话模型"),
    DEEPSEEK_REASONER("deepseek-reasoner", "DeepSeek推理模型");
    
    private final String code;
    private final String description;
    
    ModelType(String code, String description) {
        this.code = code;
        this.description = description;
    }
}

// AgentType.java
package com.legal.assistant.enums;

import lombok.Getter;

@Getter
public enum AgentType {
    LEGAL_CONSULTATION("legal_consultation", "普通法律咨询"),
    RISK_ASSESSMENT("risk_assessment", "风险评估"),
    DISPUTE_FOCUS("dispute_focus", "争议焦点"),
    CASE_ANALYSIS("case_analysis", "案件分析");
    
    private final String code;
    private final String description;
    
    AgentType(String code, String description) {
        this.code = code;
        this.description = description;
    }
}
```

### 