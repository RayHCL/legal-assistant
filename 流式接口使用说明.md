# 流式问答接口使用说明

## 接口说明

问答接口已改为流式输出（SSE - Server-Sent Events），实时返回AI回答内容。

### 接口地址
```
POST /api/chat/ask
Content-Type: application/json
Accept: text/event-stream
Authorization: Bearer {token}
```

### 请求参数
```json
{
  "question": "什么是合同纠纷？",
  "fileIds": [1, 2],
  "deepThinking": false,
  "modelType": "DEEPSEEK_CHAT",
  "temperature": 0.7,
  "agentType": "LEGAL_CONSULTATION",
  "knowledgeBaseId": 1,
  "conversationId": 1,
  "autoGenerateTitle": true
}
```

### 响应格式（SSE）

响应使用SSE格式，每个事件包含JSON数据：

```
event: message
data: {"messageId":1,"conversationId":1,"content":"根","status":"streaming","generatedTitle":null,"finished":false}

event: message
data: {"messageId":1,"conversationId":1,"content":"据","status":"streaming","generatedTitle":null,"finished":false}

event: message
data: {"messageId":1,"conversationId":1,"content":"","status":"completed","generatedTitle":"关于合同纠纷的咨询","finished":true}
```

### 响应字段说明

- **messageId**: 消息ID
- **conversationId**: 会话ID
- **content**: 当前流式输出的内容片段（单个字符或字符串片段）
- **status**: 状态
  - `thinking`: 思考中
  - `streaming`: 流式输出中
  - `completed`: 完成
  - `error`: 错误
- **generatedTitle**: 自动生成的标题（仅在首次对话且启用autoGenerateTitle时返回）
- **finished**: 是否完成（true表示流式输出结束）

## 前端使用示例

### JavaScript (Fetch API)

```javascript
async function streamChat(question) {
  const response = await fetch('/api/chat/ask', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': 'Bearer ' + token,
      'Accept': 'text/event-stream'
    },
    body: JSON.stringify({
      question: question,
      modelType: 'DEEPSEEK_CHAT',
      agentType: 'LEGAL_CONSULTATION',
      conversationId: 1,
      autoGenerateTitle: true
    })
  });

  const reader = response.body.getReader();
  const decoder = new TextDecoder();
  let buffer = '';

  while (true) {
    const { done, value } = await reader.read();
    if (done) break;

    buffer += decoder.decode(value, { stream: true });
    const lines = buffer.split('\n');
    buffer = lines.pop(); // 保留最后一个不完整的行

    for (const line of lines) {
      if (line.startsWith('data: ')) {
        const data = JSON.parse(line.substring(6));
        console.log('收到数据:', data);
        
        // 处理流式内容
        if (data.content) {
          // 追加内容到显示区域
          appendContent(data.content);
        }
        
        // 处理完成状态
        if (data.finished) {
          console.log('流式输出完成');
          if (data.generatedTitle) {
            console.log('生成的标题:', data.generatedTitle);
          }
        }
      }
    }
  }
}
```

### JavaScript (EventSource - 注意：EventSource只支持GET请求)

由于EventSource只支持GET请求，对于POST请求需要使用Fetch API。

### Vue.js 示例

```vue
<template>
  <div>
    <textarea v-model="question" placeholder="输入您的问题"></textarea>
    <button @click="sendQuestion">发送</button>
    <div class="response">{{ response }}</div>
  </div>
</template>

<script>
export default {
  data() {
    return {
      question: '',
      response: '',
      messageId: null,
      conversationId: null
    }
  },
  methods: {
    async sendQuestion() {
      this.response = '';
      
      const response = await fetch('/api/chat/ask', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer ' + this.$store.state.token,
          'Accept': 'text/event-stream'
        },
        body: JSON.stringify({
          question: this.question,
          modelType: 'DEEPSEEK_CHAT',
          agentType: 'LEGAL_CONSULTATION',
          autoGenerateTitle: true
        })
      });

      const reader = response.body.getReader();
      const decoder = new TextDecoder();
      let buffer = '';

      while (true) {
        const { done, value } = await reader.read();
        if (done) break;

        buffer += decoder.decode(value, { stream: true });
        const lines = buffer.split('\n');
        buffer = lines.pop();

        for (const line of lines) {
          if (line.startsWith('data: ')) {
            const data = JSON.parse(line.substring(6));
            
            if (data.messageId) {
              this.messageId = data.messageId;
            }
            if (data.conversationId) {
              this.conversationId = data.conversationId;
            }
            if (data.content) {
              this.response += data.content;
            }
            if (data.finished) {
              console.log('完成');
            }
          }
        }
      }
    }
  }
}
</script>
```

### React 示例

```jsx
import { useState } from 'react';

function ChatComponent() {
  const [question, setQuestion] = useState('');
  const [response, setResponse] = useState('');
  const [isStreaming, setIsStreaming] = useState(false);

  const sendQuestion = async () => {
    setResponse('');
    setIsStreaming(true);

    const res = await fetch('/api/chat/ask', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${token}`,
        'Accept': 'text/event-stream'
      },
      body: JSON.stringify({
        question,
        modelType: 'DEEPSEEK_CHAT',
        agentType: 'LEGAL_CONSULTATION',
        autoGenerateTitle: true
      })
    });

    const reader = res.body.getReader();
    const decoder = new TextDecoder();
    let buffer = '';

    while (true) {
      const { done, value } = await reader.read();
      if (done) {
        setIsStreaming(false);
        break;
      }

      buffer += decoder.decode(value, { stream: true });
      const lines = buffer.split('\n');
      buffer = lines.pop();

      for (const line of lines) {
        if (line.startsWith('data: ')) {
          const data = JSON.parse(line.substring(6));
          if (data.content) {
            setResponse(prev => prev + data.content);
          }
          if (data.finished) {
            setIsStreaming(false);
          }
        }
      }
    }
  };

  return (
    <div>
      <textarea value={question} onChange={e => setQuestion(e.target.value)} />
      <button onClick={sendQuestion} disabled={isStreaming}>
        {isStreaming ? '发送中...' : '发送'}
      </button>
      <div>{response}</div>
    </div>
  );
}
```

## 注意事项

1. **超时设置**: SSE连接默认超时时间为5分钟（300秒）
2. **错误处理**: 如果发生错误，会发送status为"error"的响应，然后关闭连接
3. **内容累积**: 前端需要累积接收到的content片段来构建完整回答
4. **连接管理**: 确保在组件卸载时关闭SSE连接，避免资源泄漏

## 测试

可以使用curl测试：

```bash
curl -X POST http://localhost:8080/api/chat/ask \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer YOUR_TOKEN" \
  -H "Accept: text/event-stream" \
  -d '{
    "question": "什么是合同纠纷？",
    "modelType": "DEEPSEEK_CHAT",
    "agentType": "LEGAL_CONSULTATION",
    "autoGenerateTitle": true
  }'
```
